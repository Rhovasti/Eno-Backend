#!/usr/bin/env python3
"""
Response generator module for the Eno game platform.
Uses the Knowledge Graph and Vector Database to generate narrative responses.
"""

import logging
import os
from typing import Dict, List, Optional, Union, Any
from dataclasses import dataclass, field
from datetime import datetime
import json

from Vector_Database.context_manager import ContextManager, NarrativeContext
from Knowledge_Graph.knowledge_manager import KnowledgeGraphManager
from Knowledge_Graph.models.entity_models import Character, Location, Event

# Set up logging
logging.basicConfig(
    filename='response_generator.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

@dataclass
class GameConfig:
    """Configuration for a game narrative"""
    name: str
    description: str
    genre: str
    themes: List[str] = field(default_factory=list)
    tone: str = "dramatic"
    world_setting: str = ""
    player_freedom: int = 5  # Scale of 1-10
    narrative_complexity: int = 5  # Scale of 1-10
    
@dataclass
class ChapterConfig:
    """Configuration for a chapter"""
    title: str
    description: str
    goals: List[str] = field(default_factory=list)
    setting: str = ""
    key_characters: List[str] = field(default_factory=list)
    key_events: List[str] = field(default_factory=list)
    
@dataclass
class BeatConfig:
    """Configuration for a narrative beat"""
    title: str
    description: str
    mood: str = "neutral"
    location: str = ""
    characters_present: List[str] = field(default_factory=list)
    goals: List[str] = field(default_factory=list)
    
@dataclass
class PostResponse:
    """Response to a post"""
    title: str
    content: str
    post_type: str = "gm"  # gm or player
    beat_id: int = 0
    

class ResponseGenerator:
    """
    Generates narrative responses for the Eno game platform.
    Uses the Knowledge Graph and Vector Database for contextual information.
    """
    
    def __init__(
        self,
        vector_db_path: str = "./narrative_db",
        embedding_model: str = "all-MiniLM-L6-v2",
        neo4j_uri: str = "bolt://localhost:7687",
        neo4j_user: str = "neo4j",
        neo4j_password: str = "nasukili12",
        neo4j_database: str = "population",
        llm_service: str = "openai",
        llm_model: str = "gpt-3.5-turbo",
        api_key: Optional[str] = None
    ):
        """
        Initialize the response generator.
        
        Args:
            vector_db_path: Path to store vector database
            embedding_model: Name of embedding model to use
            neo4j_uri: URI for Neo4j connection
            neo4j_user: Neo4j username
            neo4j_password: Neo4j password
            neo4j_database: Neo4j database name
            llm_service: LLM service to use (openai, huggingface, etc.)
            llm_model: Name of the LLM model to use
            api_key: API key for the LLM service
        """
        # Initialize context manager
        self.context_manager = ContextManager(
            vector_db_path=vector_db_path,
            embedding_model=embedding_model,
            neo4j_uri=neo4j_uri,
            neo4j_user=neo4j_user,
            neo4j_password=neo4j_password,
            neo4j_database=neo4j_database
        )
        
        # Set up LLM client (assumes OpenAI-compatible API)
        self.llm_service = llm_service
        self.llm_model = llm_model
        self.api_key = api_key or os.environ.get("OPENAI_API_KEY")
        
        if self.llm_service == "openai" and self.api_key:
            try:
                import openai
                openai.api_key = self.api_key
                self.client = openai.OpenAI(api_key=self.api_key)
                self.llm_ready = True
            except ImportError:
                logging.error("OpenAI package not installed. Install with 'pip install openai'")
                self.llm_ready = False
            except Exception as e:
                logging.error(f"Failed to initialize OpenAI client: {e}")
                self.llm_ready = False
        else:
            logging.warning("No LLM service configured, using mock responses")
            self.llm_ready = False
            
        logging.info("Initialized response generator")
    
    def _generate_llm_response(self, prompt: str, max_tokens: int = 1500) -> str:
        """
        Generate a response using the configured LLM.
        
        Args:
            prompt: The prompt to send to the LLM
            max_tokens: Maximum number of tokens to generate
            
        Returns:
            Generated text response
        """
        if not self.llm_ready:
            # Return mock response if LLM is not available
            return f"This is a mock response. In production, this would be generated by the {self.llm_model} model."
            
        try:
            if self.llm_service == "openai":
                response = self.client.chat.completions.create(
                    model=self.llm_model,
                    messages=[
                        {"role": "system", "content": "You are a narrative AI assistant for a tabletop RPG game."},
                        {"role": "user", "content": prompt}
                    ],
                    max_tokens=max_tokens,
                    temperature=0.7
                )
                return response.choices[0].message.content
            else:
                return "Unsupported LLM service"
        except Exception as e:
            logging.error(f"Error generating LLM response: {e}")
            return f"Error generating response: {str(e)}"
    
    def create_game_narrative(self, config: GameConfig) -> str:
        """
        Create a narrative for a new game.
        
        Args:
            config: Game configuration
            
        Returns:
            Generated narrative
        """
        prompt = f"""
        Create a compelling narrative introduction for a new tabletop RPG game with the following details:
        
        Game Name: {config.name}
        Description: {config.description}
        Genre: {config.genre}
        Themes: {', '.join(config.themes)}
        Tone: {config.tone}
        World Setting: {config.world_setting}
        
        Your task is to write an engaging introduction that sets the stage for this game world. 
        Include key themes, conflicts, and the general atmosphere of the setting.
        Write in a way that invites players to immerse themselves in this world.
        
        The narrative should be between 500-1000 words and should end with a hook that gets players excited to begin their adventure.
        """
        
        # Store basic game info in knowledge graph
        if hasattr(self.context_manager, 'kg_manager') and self.context_manager.kg_connected:
            try:
                # Create location for the game world
                world_location = Location(
                    name=config.name + " World",
                    description=config.description,
                    properties={
                        "genre": config.genre,
                        "themes": config.themes,
                        "tone": config.tone
                    }
                )
                self.context_manager.kg_manager.create_location(world_location)
                
                # Store game metadata as an event
                game_event = Event(
                    name=config.name + " Game Creation",
                    description="Initial creation of the game narrative",
                    event_type="game_creation",
                    timestamp=datetime.now().isoformat(),
                    properties={
                        "game_name": config.name,
                        "genre": config.genre,
                        "themes": config.themes,
                        "tone": config.tone
                    }
                )
                self.context_manager.kg_manager.create_event(game_event)
                
            except Exception as e:
                logging.error(f"Error storing game info in knowledge graph: {e}")
        
        # Generate the narrative
        narrative = self._generate_llm_response(prompt)
        
        # Store the narrative in vector database
        self.context_manager.add_narrative_memory(
            text=narrative,
            source="system",
            related_entities=[(config.name + " World", "Location")],
            importance=10,
            tags=["game_narrative", "introduction", config.genre] + config.themes
        )
        
        return narrative
    
    def create_chapter_narrative(self, game_name: str, config: ChapterConfig) -> str:
        """
        Create a narrative for a new chapter.
        
        Args:
            game_name: Name of the game
            config: Chapter configuration
            
        Returns:
            Generated chapter narrative
        """
        # Fetch game context
        game_context = self.context_manager.get_context_for_query(
            query=game_name,
            n_memories=5
        )
        
        prompt = f"""
        Create a narrative introduction for a new chapter in the game "{game_name}" with the following details:
        
        Chapter Title: {config.title}
        Description: {config.description}
        Setting: {config.setting}
        Goals: {', '.join(config.goals)}
        Key Characters: {', '.join(config.key_characters)}
        
        Game Context:
        {game_context.to_text()}
        
        Your task is to write an engaging chapter introduction that builds on the existing game narrative.
        Focus on the setting, the key characters, and establish the main goals or conflicts for this chapter.
        Write in a way that transitions smoothly from previous events while setting up new challenges.
        
        The narrative should be between 300-600 words and should end with a hook that gets players excited to begin this chapter.
        """
        
        # Store chapter info in knowledge graph
        if hasattr(self.context_manager, 'kg_manager') and self.context_manager.kg_connected:
            try:
                # Create location for the chapter setting if it doesn't exist
                if config.setting:
                    chapter_location = Location(
                        name=config.setting,
                        description=f"Setting for chapter '{config.title}' in game '{game_name}'",
                        properties={
                            "chapter_title": config.title,
                            "game_name": game_name
                        }
                    )
                    self.context_manager.kg_manager.create_location(chapter_location)
                
                # Create characters if they don't exist
                for character_name in config.key_characters:
                    existing_character = self.context_manager.kg_manager.get_character(character_name)
                    if not existing_character:
                        character = Character(
                            name=character_name,
                            description=f"Character in chapter '{config.title}'",
                            properties={
                                "chapter_title": config.title,
                                "game_name": game_name
                            }
                        )
                        self.context_manager.kg_manager.create_character(character)
                
                # Store chapter as an event
                chapter_event = Event(
                    name=config.title,
                    description=config.description,
                    event_type="chapter_creation",
                    timestamp=datetime.now().isoformat(),
                    properties={
                        "game_name": game_name,
                        "setting": config.setting,
                        "goals": config.goals,
                        "key_characters": config.key_characters
                    }
                )
                self.context_manager.kg_manager.create_event(chapter_event)
                
            except Exception as e:
                logging.error(f"Error storing chapter info in knowledge graph: {e}")
        
        # Generate the narrative
        narrative = self._generate_llm_response(prompt)
        
        # Store in vector database
        related_entities = [(config.title, "Event")]
        if config.setting:
            related_entities.append((config.setting, "Location"))
            
        self.context_manager.add_narrative_memory(
            text=narrative,
            source="system",
            related_entities=related_entities,
            location=config.setting if config.setting else None,
            importance=8,
            tags=["chapter_narrative", "introduction", game_name]
        )
        
        return narrative
    
    def create_beat_narrative(
        self,
        game_name: str,
        chapter_title: str,
        config: BeatConfig
    ) -> str:
        """
        Create a narrative for a new beat.
        
        Args:
            game_name: Name of the game
            chapter_title: Title of the chapter
            config: Beat configuration
            
        Returns:
            Generated beat narrative
        """
        # Get context from chapter and game
        context = self.context_manager.get_context_for_query(
            query=f"{chapter_title} {game_name}",
            location_name=config.location if config.location else None,
            n_memories=8
        )
        
        # Get character information
        character_descriptions = []
        for char_name in config.characters_present:
            char_context = self.context_manager.get_entity_context(
                entity_name=char_name,
                entity_type="Character",
                n_memories=3
            )
            if "entity" in char_context and char_context["entity"]:
                character_descriptions.append(f"{char_name}: {char_context['entity'].description}")
            else:
                character_descriptions.append(f"{char_name}: A character in this narrative beat")
        
        prompt = f"""
        Create a narrative for a new beat in the chapter "{chapter_title}" of game "{game_name}" with the following details:
        
        Beat Title: {config.title}
        Description: {config.description}
        Mood: {config.mood}
        Location: {config.location}
        Characters Present: {', '.join(config.characters_present)}
        Goals: {', '.join(config.goals)}
        
        Character Details:
        {chr(10).join(character_descriptions)}
        
        Context:
        {context.to_text()}
        
        Your task is to write a detailed beat narrative that advances the story of this chapter.
        Focus on the atmosphere of the location, the interactions between characters, and the progress toward goals.
        Write in a way that creates tension, reveals character motivations, and sets up interesting choices for players.
        
        The narrative should be between 300-500 words and should end with a situation that invites player response.
        """
        
        # Store beat info in knowledge graph
        if hasattr(self.context_manager, 'kg_manager') and self.context_manager.kg_connected:
            try:
                # Create beat as an event
                beat_event = Event(
                    name=config.title,
                    description=config.description,
                    event_type="narrative_beat",
                    timestamp=datetime.now().isoformat(),
                    properties={
                        "game_name": game_name,
                        "chapter_title": chapter_title,
                        "mood": config.mood,
                        "location": config.location,
                        "characters_present": config.characters_present,
                        "goals": config.goals
                    }
                )
                event_id = self.context_manager.kg_manager.create_event(beat_event)
                
                # Connect beat to characters
                for char_name in config.characters_present:
                    character = self.context_manager.kg_manager.get_character(char_name)
                    if character:
                        self.context_manager.kg_manager.create_relationship(
                            beat_event,
                            "INVOLVES",
                            character,
                            {"beat_title": config.title}
                        )
                
                # Connect beat to location
                if config.location:
                    location = self.context_manager.kg_manager.get_location(config.location)
                    if not location:
                        # Create location if it doesn't exist
                        location = Location(
                            name=config.location,
                            description=f"Location in beat '{config.title}'",
                            properties={
                                "beat_title": config.title,
                                "chapter_title": chapter_title,
                                "game_name": game_name
                            }
                        )
                        self.context_manager.kg_manager.create_location(location)
                    
                    self.context_manager.kg_manager.create_relationship(
                        beat_event,
                        "OCCURS_AT",
                        location,
                        {"beat_title": config.title}
                    )
                
            except Exception as e:
                logging.error(f"Error storing beat info in knowledge graph: {e}")
        
        # Generate the narrative
        narrative = self._generate_llm_response(prompt)
        
        # Store in vector database
        related_entities = [(config.title, "Event")]
        if config.location:
            related_entities.append((config.location, "Location"))
        
        for char_name in config.characters_present:
            related_entities.append((char_name, "Character"))
            
        self.context_manager.add_narrative_memory(
            text=narrative,
            source="system",
            related_entities=related_entities,
            location=config.location if config.location else None,
            importance=7,
            tags=["beat_narrative", chapter_title, game_name]
        )
        
        return narrative
    
    def generate_post_response(
        self,
        beat_id: int,
        post_content: str,
        character_name: Optional[str] = None,
        post_type: str = "gm"
    ) -> PostResponse:
        """
        Generate a response to a post in a beat.
        
        Args:
            beat_id: ID of the beat
            post_content: Content of the post to respond to
            character_name: Optional name of the character (for player posts)
            post_type: Type of post to generate (gm or player)
            
        Returns:
            Generated post response
        """
        # Extract beat information from post content
        beat_info = {}
        try:
            # Try to extract beat title, game name, etc. from post content
            lines = post_content.split('\n')
            for line in lines[:10]:  # Check first 10 lines
                if ':' in line:
                    key, value = line.split(':', 1)
                    beat_info[key.strip().lower()] = value.strip()
        except Exception as e:
            logging.error(f"Error extracting beat info: {e}")
        
        # Get context based on post content
        context = self.context_manager.get_context_for_query(
            query=post_content,
            character_name=character_name,
            location_name=beat_info.get('location'),
            n_memories=10
        )
        
        # Determine response type
        response_type = "GM response" if post_type == "gm" else "Character response"
        character_context = ""
        
        if character_name:
            # Get character context if a character name is provided
            char_context = self.context_manager.get_entity_context(
                entity_name=character_name,
                entity_type="Character",
                n_memories=3
            )
            if "entity" in char_context and char_context["entity"]:
                character_context = f"""
                Character: {character_name}
                Description: {char_context['entity'].description}
                Memories related to this character:
                {chr(10).join([f"- {memory.text}" for memory in char_context.get('memories', [])])}
                """
        
        prompt = f"""
        Generate a {response_type} to the following post in a narrative RPG:
        
        Post Content:
        {post_content}
        
        {character_context}
        
        Context Information:
        {context.to_text()}
        
        Your task is to write an engaging response that advances the narrative in a meaningful way.
        If responding as a GM, focus on developing the scene, introducing complications, and providing opportunities for character development.
        If responding as a character, ensure the response matches the character's voice, motivations, and knowledge.
        
        The response should be between 200-600 words and should maintain the established tone of the narrative.
        Include dialogue, description, and action in a balanced way.
        End with something that invites further engagement or response.
        """
        
        # Generate response content
        content = self._generate_llm_response(prompt)
        
        # Generate an appropriate title
        title_prompt = f"""
        Create a short, engaging title (5-10 words) for the following narrative post:
        
        {content[:200]}...
        
        The title should capture the essence of the post while being intriguing.
        """
        
        title = self._generate_llm_response(title_prompt, max_tokens=50).strip()
        
        # Store in vector database
        beat_title = beat_info.get('beat title', f"Beat {beat_id}")
        
        related_entities = [(beat_title, "Event")]
        if character_name:
            related_entities.append((character_name, "Character"))
        if 'location' in beat_info:
            related_entities.append((beat_info['location'], "Location"))
            
        self.context_manager.add_narrative_memory(
            text=content,
            source="system" if post_type == "gm" else character_name,
            related_entities=related_entities,
            location=beat_info.get('location'),
            importance=6,
            tags=["post_response", beat_title]
        )
        
        return PostResponse(
            title=title,
            content=content,
            post_type=post_type,
            beat_id=beat_id
        )